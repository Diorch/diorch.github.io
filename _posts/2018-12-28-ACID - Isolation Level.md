事务的隔离性是指多个事务**并发执行**的时候相互之间不受到彼此的干扰的特性，隔离性是事务ACID特性中的I，根据隔离程度从低到高分为Read Uncommitted（读未提交），Read Committed（读已提交），Repeatable Read（可重复读），Serializable（串行化）四种隔离级别。



#### READ UNCOMMITTED

该隔离级别对事务提供的保护最少，能读到其他事务尚未提交的数据（commit），虽然在4大隔离级别中性能最好，但是就是由于允许读取未提交的数据，那么当其他事务回滚（rollback）时，就造成了「脏读」（dirty read），比如，事务A中对某一条数据执行两次查询 q1 和 q2，执行 q1前，事务 B 修改该条数据，该条数据处于装啊提 s1，q1执行后，事务 B 发生异常导致数据恢复至 s0，事务 A 执行 q2，再次查询该数据时，该数据处于 s0，这就是「脏读」。

#### READ COMMITTED

基于性能考虑，降低并发事务间的隔离程度。假设一个时段内仅有 A 和 B 两个事务处理同一条数据，从 t1开始至 B 事务提交事务的时刻 t2 为止，当某一时刻 A 事务提交（commit），B 事务仍未提交，下一个时刻，B 事务读取该条数据时读到的是 A 事务提交后的数据。如果 A 事务未提交，则 B 事务读取到的是 A 修改前的数据。由此造成了「 不可重复读」。

处于该隔离级别下的事务，实际对事务执行产生的影响可以这么理解，当 A 和 B 并发操作同一条数据，A 执行 `UPDATE ... WHERE` 或 `DELETE ... WHERE` 时，其他事务对该条数据的操作需要等待。而`SELECT ... FOR UPDATE` 和 `LOCK IN SHARE MODE`不会引起其他事务的等待。

#### REPEATABLE READ

A事务在读取数据 D1 将阻塞 B 事务对 D1的修改。处于该隔离级别下的事务，可以保证不出现「不可重复读」，但无法保证不发生「幻读」（phantom）。其原理是，使用锁策略，使得其他事务读取某条数据的在执行 A 事务前的快照（snapshot）。

「幻读」，在 A 事务中，同一个查询条件先后执行两次分别为 q1和 q2，q2取得的结果集set2中的某条数据在q1取得的结果集 set1中数据不一致或者不存在。举个场景，当 A 事务执行期间，B 事务插入或者更新该条数据，导致 A 事务的 q1与 q2结果不匹配。

处于该隔离级别下的事务，实际对事物执行产生的影响可以这么理解，当 A 和 B 并发操作同一条数据，A 执行`UPDATE ... WHERE`, `DELETE ... WHERE`, `SELECT ... FOR UPDATE`,  `LOCK IN SHARE MODE`时，其他事务需要等待。